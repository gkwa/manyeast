-- Makefile --
BIN := littlewill
PREFIX := github.com/gkwa/littlewill/version

SRC := $(shell find . -name '*.go')

DATE := $(shell date +"%Y-%m-%dT%H:%M:%SZ")
GOVERSION := $(shell go version)
VERSION := $(shell git describe --tags --abbrev=8 --dirty --always --long)
SHORT_SHA := $(shell git rev-parse --short HEAD)
FULL_SHA := $(shell git rev-parse HEAD)
export GOVERSION # goreleaser wants this

LDFLAGS = -s -w
LDFLAGS += -X $(PREFIX).Version=$(VERSION)
LDFLAGS += -X '$(PREFIX).Date=$(DATE)'
LDFLAGS += -X '$(PREFIX).GoVersion=$(GOVERSION)'
LDFLAGS += -X $(PREFIX).ShortGitSHA=$(SHORT_SHA)
LDFLAGS += -X $(PREFIX).FullGitSHA=$(FULL_SHA)

.DEFAULT_GOAL := iterate

all: check $(BIN) install

.PHONY: iterate # lint and rebuild
iterate: check $(BIN)

.PHONY: check # lint and vet
check: .timestamps/.check.time

.timestamps/.check.time: tidy fmt imports lint vet
	@mkdir -p .timestamps
	@touch $@

.PHONY: build # build
build: $(BIN)

$(BIN): .timestamps/.build.time .timestamps/.tidy.time
	go build -ldflags "$(LDFLAGS)" -o $@

.timestamps/.build.time: $(SRC)
	@mkdir -p .timestamps
	@touch $@

.PHONY: goreleaser # run goreleaser
goreleaser: goreleaser --clean

.PHONY: imports # goimports
imports: .timestamps/.imports.time
.timestamps/.imports.time: $(SRC)
	goimports -w $(SRC)
	@mkdir -p .timestamps
	@touch $@

.PHONY: tidy # go mod tidy
tidy: .timestamps/.tidy.time

.timestamps/.tidy.time: go.mod go.sum
	go mod tidy
	@mkdir -p .timestamps
	@touch $@

.PHONY: fmt # go fmt
fmt: .timestamps/.fmt.time

.timestamps/.fmt.time: $(SRC)
	gofumpt -extra -w $(SRC)
	@mkdir -p .timestamps
	@touch $@

.PHONY: test # run all tests
test:
	go test ./...

.PHONY: lint # lint
lint: .timestamps/.lint.time

.timestamps/.lint.time: $(SRC)
	golangci-lint run
	@mkdir -p .timestamps
	@touch $@

.PHONY: vet # go vet
vet: .timestamps/.vet.time

.timestamps/.vet.time: $(SRC)
	go vet ./...
	@mkdir -p .timestamps
	@touch $@

.PHONY: install # go install
install: imports
	go install -ldflags "$(LDFLAGS)"

.PHONY: help # show makefile rules
help:
	@grep '^.PHONY: .* #' Makefile | sed 's/\.PHONY: \(.*\) # \(.*\)/\1 \2/' | expand -t20

.PHONY: clean # clean bin
clean:
	$(RM) -r $(BIN) .timestamps
-- cmd/e2e_test.go --
package cmd

import (
	"bytes"
	"context"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/spf13/cobra"
)

func TestProcessPathsFromStdin(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: "URLs outside code blocks are processed, URLs inside are not",
			input: `Check this link: https://www.google.com/search?q=test&hl=en
` + "```" + `
var url = "https://www.google.com/search?q=test&hl=en";
` + "```" + `
Another link: https://www.google.com/search?q=example&hl=en`,
			expected: `Check this link: https://www.google.com/search?q=test
` + "```" + `
var url = "https://www.google.com/search?q=test&hl=en";
` + "```" + `
Another link: https://www.google.com/search?q=example`,
		},
		{
			name: "YouTube URLs are processed correctly",
			input: `Watch this video: https://www.youtube.com/watch?v=dQw4w9WgXcQ&si=abcdefghijklmnop
` + "```" + `
const youtubeUrl = "https://youtu.be/dQw4w9WgXcQ?si=abcdefghijklmnop";
` + "```" + `
Another video: https://youtu.be/dQw4w9WgXcQ?si=qrstuvwxyz123456`,
			expected: `Watch this video: https://www.youtube.com/watch?v=dQw4w9WgXcQ
` + "```" + `
const youtubeUrl = "https://youtu.be/dQw4w9WgXcQ?si=abcdefghijklmnop";
` + "```" + `
Another video: https://youtu.be/dQw4w9WgXcQ`,
		},
		{
			name: "Substack URLs are processed correctly",
			input: `Read this article: https://example.substack.com/p/article-title?utm_source=twitter&utm_medium=social
` + "```" + `
const substackUrl = "https://another.substack.com/p/another-article?utm_campaign=post";
` + "```" + `
Another article: https://third.substack.com/p/third-article?utm_source=copy&utm_medium=reader2`,
			expected: `Read this article: https://example.substack.com/p/article-title
` + "```" + `
const substackUrl = "https://another.substack.com/p/another-article?utm_campaign=post";
` + "```" + `
Another article: https://third.substack.com/p/third-article`,
		},
		{
			name: "Mixed URL types are processed correctly",
			input: `Google: https://www.google.com/search?q=test&hl=en
YouTube: https://www.youtube.com/watch?v=dQw4w9WgXcQ&si=abcdefghijklmnop
Substack: https://example.substack.com/p/article-title?utm_source=twitter
` + "```" + `
const urls = {
  google: "https://www.google.com/search?q=test&hl=en",
  youtube: "https://youtu.be/dQw4w9WgXcQ?si=abcdefghijklmnop",
  substack: "https://example.substack.com/p/article-title?utm_source=twitter"
};
` + "```" + `
More links:
Google: https://www.google.com/search?q=example&hl=fr
YouTube: https://youtu.be/dQw4w9WgXcQ?si=qrstuvwxyz123456
Substack: https://another.substack.com/p/another-article?utm_campaign=post`,
			expected: `Google: https://www.google.com/search?q=test
YouTube: https://www.youtube.com/watch?v=dQw4w9WgXcQ
Substack: https://example.substack.com/p/article-title
` + "```" + `
const urls = {
  google: "https://www.google.com/search?q=test&hl=en",
  youtube: "https://youtu.be/dQw4w9WgXcQ?si=abcdefghijklmnop",
  substack: "https://example.substack.com/p/article-title?utm_source=twitter"
};
` + "```" + `
More links:
Google: https://www.google.com/search?q=example
YouTube: https://youtu.be/dQw4w9WgXcQ
Substack: https://another.substack.com/p/another-article`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a temporary file to store the input content
			tempFile, err := os.CreateTemp("", "test_stdin_*.txt")
			if err != nil {
				t.Fatalf("Failed to create temp file: %v", err)
			}
			defer os.Remove(tempFile.Name())

			// Write the input content to the temporary file
			if _, err := tempFile.Write([]byte(tc.input)); err != nil {
				t.Fatalf("Failed to write to temp file: %v", err)
			}
			tempFile.Close()

			// Create another temporary file to simulate stdin
			stdinFile, err := os.CreateTemp("", "test_stdin_paths_*.txt")
			if err != nil {
				t.Fatalf("Failed to create stdin temp file: %v", err)
			}
			defer os.Remove(stdinFile.Name())

			// Write the path of the input file to the stdin file
			if _, err := stdinFile.WriteString(tempFile.Name() + "\n"); err != nil {
				t.Fatalf("Failed to write to stdin temp file: %v", err)
			}
			stdinFile.Close()

			// Save the original stdin and restore it after the test
			oldStdin := os.Stdin
			defer func() { os.Stdin = oldStdin }()

			// Redirect stdin to read from the stdin file
			stdin, err := os.Open(stdinFile.Name())
			if err != nil {
				t.Fatalf("Failed to open stdin temp file: %v", err)
			}
			defer stdin.Close()
			os.Stdin = stdin

			// Capture stdout
			oldStdout := os.Stdout
			r, w, _ := os.Pipe()
			os.Stdout = w

			// Create a test context
			ctx := context.Background()

			// Create a dummy cobra.Command
			cmd := &cobra.Command{}
			cmd.SetContext(ctx)

			// Run the pathsFromStdinCmd's Run function
			pathsFromStdinCmd.Run(cmd, []string{})

			// Restore stdout
			w.Close()
			os.Stdout = oldStdout

			var buf bytes.Buffer
			_, err = io.Copy(&buf, r)
			if err != nil {
				t.Fatalf("Failed to copy pipe to buffer: %v", err)
			}

			// Read the content of the processed file
			processedContent, err := os.ReadFile(tempFile.Name())
			if err != nil {
				t.Fatalf("Failed to read processed file: %v", err)
			}

			// Check the output
			if strings.TrimSpace(string(processedContent)) != tc.expected {
				t.Errorf("Expected output:\n%s\n\nGot:\n%s", tc.expected, strings.TrimSpace(string(processedContent)))
			}
		})
	}
}
-- cmd/root.go --
package cmd

import (
	"context"
	"fmt"
	"io"
	"os"

	"github.com/gkwa/littlewill/core/links"
	"github.com/gkwa/littlewill/internal/logger"
	"github.com/go-logr/logr"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	cfgFile   string
	verbose   bool
	logFormat string
	cliLogger logr.Logger
)

var linkTransforms = []func(io.Reader, io.Writer) error{
	links.RemoveGenericTrackingParams,
	links.RemoveParamsFromGoogleURLs,
	links.RemoveParamsFromYouTubeURLs,
	links.RemoveParamsFromSubstackURLs,
	links.RemoveParamsFromTheSweeklyURLs,
	links.RemoveTextFragmentsFromURLs,
	links.RemoveYouTubeCountFromMarkdownLinks,
}

var rootCmd = &cobra.Command{
	Use:   "littlewill",
	Short: "A brief description of your application",
	Long:  `A longer description that spans multiple lines and likely contains examples and usage of using your application.`,
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		// Initialize the console logger just before running
		// a command only if one wasn't provided. This allows other
		// callers (e.g. unit tests) to inject their own logger ahead of time.
		if cliLogger.IsZero() {
			cliLogger = logger.NewConsoleLogger(verbose, logFormat == "json")
		}

		ctx := logr.NewContext(context.Background(), cliLogger)
		cmd.SetContext(ctx)
	},
}

func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.littlewill.yaml)")
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "enable verbose mode")
	rootCmd.PersistentFlags().StringVar(&logFormat, "log-format", "", "json or text (default is text)")

	if err := viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose")); err != nil {
		fmt.Printf("Error binding verbose flag: %v\n", err)
		os.Exit(1)
	}
	if err := viper.BindPFlag("log-format", rootCmd.PersistentFlags().Lookup("log-format")); err != nil {
		fmt.Printf("Error binding log-format flag: %v\n", err)
		os.Exit(1)
	}
}

func initConfig() {
	if cfgFile != "" {
		viper.SetConfigFile(cfgFile)
	} else {
		home, err := os.UserHomeDir()
		cobra.CheckErr(err)

		viper.AddConfigPath(home)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".littlewill")
	}

	viper.AutomaticEnv()

	if err := viper.ReadInConfig(); err == nil {
		fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
	}

	logFormat = viper.GetString("log-format")
	verbose = viper.GetBool("verbose")
}

func LoggerFrom(ctx context.Context, keysAndValues ...interface{}) logr.Logger {
	if cliLogger.IsZero() {
		cliLogger = logger.NewConsoleLogger(verbose, logFormat == "json")
	}
	newLogger := cliLogger
	if ctx != nil {
		if l, err := logr.FromContext(ctx); err == nil {
			newLogger = l
		}
	}
	return newLogger.WithValues(keysAndValues...)
}
-- cmd/root_test.go --
package cmd

import (
	"bytes"
	"encoding/json"
	"io"
	"os"
	"strings"
	"testing"

	"github.com/gkwa/littlewill/internal/logger"
	"github.com/go-logr/zapr"
	"github.com/spf13/cobra"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

func TestCustomLogger(t *testing.T) {
	var buf bytes.Buffer

	zapConfig := zap.NewDevelopmentConfig()
	zapConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
	zapLogger := zap.New(zapcore.NewCore(
		zapcore.NewConsoleEncoder(zapConfig.EncoderConfig),
		zapcore.AddSync(&buf),
		zapcore.DebugLevel,
	))

	customLogger := zapr.NewLogger(zapLogger)

	cliLogger = customLogger

	// Create a test command that uses the logger
	testCmd := &cobra.Command{
		Use: "test",
		Run: func(cmd *cobra.Command, args []string) {
			logger := LoggerFrom(cmd.Context())
			logger.Info("Test log message")
		},
	}
	rootCmd.AddCommand(testCmd)

	// Execute the test command
	cmd := rootCmd
	cmd.SetArgs([]string{"test"})
	err := cmd.Execute()
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	logOutput := buf.String()
	if logOutput == "" {
		t.Error("Expected log output, but got none")
	}

	if !strings.Contains(logOutput, "Test log message") {
		t.Errorf("Expected log output to contain 'Test log message', but got: %s", logOutput)
	}

	t.Logf("Log output: %s", logOutput)
}

func TestJSONLogger(t *testing.T) {
	oldVerbose, oldLogFormat := verbose, logFormat
	verbose, logFormat = true, "json"
	defer func() {
		verbose, logFormat = oldVerbose, oldLogFormat
	}()

	oldStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	customLogger := logger.NewConsoleLogger(verbose, logFormat == "json")
	cliLogger = customLogger

	// Create a test command that uses the logger
	testCmd := &cobra.Command{
		Use: "test",
		Run: func(cmd *cobra.Command, args []string) {
			logger := LoggerFrom(cmd.Context())
			logger.Info("Test log message")
		},
	}
	rootCmd.AddCommand(testCmd)

	// Execute the test command
	cmd := rootCmd
	cmd.SetArgs([]string{"test"})
	err := cmd.Execute()
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}

	w.Close()
	os.Stderr = oldStderr

	var buf bytes.Buffer
	_, err = io.Copy(&buf, r)
	if err != nil {
		t.Fatalf("Failed to copy log output: %v", err)
	}
	logOutput := buf.String()

	if logOutput == "" {
		t.Error("Expected log output, but got none")
	}

	lines := strings.Split(strings.TrimSpace(logOutput), "\n")
	for _, line := range lines {
		var jsonMap map[string]interface{}
		err := json.Unmarshal([]byte(line), &jsonMap)
		if err != nil {
			t.Errorf("Expected valid JSON, but got error: %v", err)
		}

		if message, ok := jsonMap["message"]; ok {
			if message != "Test log message" {
				t.Errorf("Expected log message 'Test log message', but got: %v", message)
			}
		} else {
			t.Error("Expected 'message' field in JSON log output, but it was not found")
		}
	}

	t.Logf("Log output: %s", logOutput)
}
-- cmd/stdin.go --
package cmd

import (
	"github.com/gkwa/littlewill/core"
	"github.com/spf13/cobra"
)

var pathsFromStdinCmd = &cobra.Command{
	Use:     "paths-from-stdin",
	Aliases: []string{"pfs"},
	Short:   "Process a list of paths from stdin",
	Long:    `This command reads a list of file paths from standard input and processes them, cleaning up markdown links in each file.`,
	Run: func(cmd *cobra.Command, args []string) {
		core.ProcessPathsFromStdin(cmd.Context(), linkTransforms...)
	},
}

func init() {
	rootCmd.AddCommand(pathsFromStdinCmd)
}
-- cmd/version.go --
package cmd

import (
	"fmt"

	"github.com/gkwa/littlewill/version"
	"github.com/spf13/cobra"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number of littlewill",
	Long:  `All software has versions. This is littlewill's`,
	Run: func(cmd *cobra.Command, args []string) {
		buildInfo := version.GetBuildInfo()
		fmt.Println(buildInfo)
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}
-- cmd/watchDir.go --
package cmd

import (
	"github.com/gkwa/littlewill/watcher"
	"github.com/spf13/cobra"
)

var (
	patterns   []string
	filterType string
)

var watchDirCmd = &cobra.Command{
	Use:     "watch-dir <directory>",
	Aliases: []string{"wd"},
	Args:    cobra.ExactArgs(1),
	Short:   "Watch a directory for file changes",
	Long: `Watch a directory for file changes and process modified files.

You can specify patterns to filter which files to watch. If no patterns are specified,
all files will be watched. Patterns use standard glob syntax.

Examples:
  littlewill watch-dir /path/to/directory
  littlewill watch-dir /path/to/directory --patterns "*.md,*.txt"
  littlewill watch-dir /path/to/directory --patterns "doc_*.md" --patterns "report_*.txt"`,
	Run: func(cmd *cobra.Command, args []string) {
		dir := args[0]
		watcher.RunWatcher(
			cmd.Context(),
			dir,
			patterns,
			filterType,
			linkTransforms,
		)
	},
}

func init() {
	rootCmd.AddCommand(watchDirCmd)

	watchDirCmd.Flags().StringSliceVarP(&patterns, "patterns", "p", []string{}, `File patterns to watch (comma-separated or multiple flags).
Examples:
  --patterns "*.md,*.txt"
  --patterns "*.go" --patterns "*.yaml"
Default: watch all files`)

	watchDirCmd.Flags().StringVarP(&filterType, "filter-type", "f", "write", `Event type to filter on. Options:
  create: Only watch for new files
  write: Watch for file modifications (default)
  remove: Watch for file deletions
  rename: Watch for file renames
  chmod: Watch for permission changes`)
}
-- core/file.go --
package core

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"os"

	"github.com/gkwa/littlewill/file"
	"github.com/go-logr/logr"
)

func ProcessFile(
	logger logr.Logger,
	path string,
	transforms ...func(io.Reader, io.Writer) error,
) error {
	// skip past symlinks
	f := file.File{Path: path}

	isSymlink, err := f.IsSymlink()
	if err != nil {
		logger.Error(err, "Failed to check if path is symlink", "path", path)
	}
	logger.V(1).Info("file type check", "path", path, "type", f.FileType())

	if isSymlink {
		logger.V(1).Info("skipping symlink", "path", path)
		return nil
	}

	// ok we get to files now
	originalContent, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read original file: %w", err)
	}

	processedContent, err := ApplyTransforms(originalContent, transforms...)
	if err != nil {
		return fmt.Errorf("failed to process file: %w", err)
	}

	if bytes.Equal(originalContent, processedContent) {
		logger.V(1).Info("File content unchanged, skipping write")
		return nil
	}

	err = os.WriteFile(path, processedContent, 0o644)
	if err != nil {
		return fmt.Errorf("failed to write processed content to file: %w", err)
	}

	logger.V(1).Info("Successfully processed and updated file")
	return nil
}

func ReadPathsFromStdin() ([]string, error) {
	var paths []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		paths = append(paths, scanner.Text())
	}
	return paths, scanner.Err()
}

func ProcessPaths(ctx context.Context, paths []string, transforms ...func(io.Reader, io.Writer) error) {
	logger := logr.FromContextOrDiscard(ctx)

	for _, path := range paths {
		logger.V(1).Info("Processing path", "path", path)
		err := ProcessFile(logger, path, transforms...)
		if err != nil {
			logger.Error(err, "Failed to process file", "path", path)
		}
	}
}

func ProcessPathsFromStdin(ctx context.Context, transforms ...func(io.Reader, io.Writer) error) {
	logger := logr.FromContextOrDiscard(ctx)
	logger.V(1).Info("Processing paths from stdin")

	paths, err := ReadPathsFromStdin()
	if err != nil {
		logger.Error(err, "Error reading input")
		return
	}

	ProcessPaths(ctx, paths, transforms...)
}
-- core/links/generic.go --
package links

import (
	"fmt"
	"io"
	"net/url"
	"strings"

	"mvdan.cc/xurls/v2"
)

// Common tracking parameters that should be removed from URLs
var GenericParamsToRemove = []string{
	"_ga",
	"_ga_ECJJ2Q2SJQ", // Google Analytics 4 session tracking parameter
	"_gl",
	"campaign",
	"fbclid",
	"gclid",
	"mc_cid",
	"mc_eid",
	"medium",
	"ncid",
	"ocid",
	"source",
	"srsltid",
	"utm_campaign",
	"utm_content",
	"utm_id",
	"utm_medium",
	"utm_source",
	"utm_term",
}

// RemoveGenericTrackingParams removes common tracking parameters from all URLs
func RemoveGenericTrackingParams(r io.Reader, w io.Writer) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("RemoveGenericTrackingParams: failed to read input: %w", err)
	}

	codeBlockLevel := 0
	lines := strings.Split(string(buf), "\n")
	for i, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimmedLine, "```") {
			if codeBlockLevel == 0 {
				codeBlockLevel++
			} else {
				codeBlockLevel--
			}
		}

		if codeBlockLevel == 0 {
			rxStrict := xurls.Strict()
			lines[i] = rxStrict.ReplaceAllStringFunc(line, func(match string) string {
				u, err := url.Parse(match)
				if err != nil {
					return match
				}

				q := u.Query()
				changed := false

				for _, param := range GenericParamsToRemove {
					if q.Has(param) {
						q.Del(param)
						changed = true
					}
				}

				if changed {
					u.RawQuery = q.Encode()
					return u.String()
				}

				return match
			})
		}
	}

	_, err = w.Write([]byte(strings.Join(lines, "\n")))
	if err != nil {
		return fmt.Errorf("RemoveGenericTrackingParams: failed to write output: %w", err)
	}
	return nil
}
-- core/links/generic_test.go --
package links

import (
	"bytes"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestRemoveGenericTrackingParams(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "URL with UTM parameters",
			input:    "https://research.swtch.com/diffcover?utm_source=christophberger&utm_medium=email&utm_campaign=2025-04-27-the-attack-you-invited",
			expected: "https://research.swtch.com/diffcover",
		},
		{
			name:     "URL with mixed parameters",
			input:    "https://example.com/article?id=123&utm_source=newsletter&page=2",
			expected: "https://example.com/article?id=123&page=2",
		},
		{
			name:     "URL without tracking parameters",
			input:    "https://example.com/page?id=123&category=tech",
			expected: "https://example.com/page?id=123&category=tech",
		},
		{
			name:     "URL with only tracking parameters",
			input:    "https://example.com/landing?utm_source=ads&utm_medium=social&utm_campaign=summer",
			expected: "https://example.com/landing",
		},
		{
			name:     "URL with Facebook click ID",
			input:    "https://example.com/product?id=456&fbclid=abc123",
			expected: "https://example.com/product?id=456",
		},
		{
			name: "Multiple URLs in text",
			input: `Check out these links:
https://research.swtch.com/diffcover?utm_source=christophberger&utm_medium=email&utm_campaign=2025-04-27-the-attack-you-invited
https://example.com/article?id=123&utm_source=newsletter&page=2`,
			expected: `Check out these links:
https://research.swtch.com/diffcover
https://example.com/article?id=123&page=2`,
		},
		{
			name: "URLs inside code blocks should not be processed",
			input: `Check this URL: https://research.swtch.com/diffcover?utm_source=christophberger&utm_medium=email

` + "```" + `
var url = "https://research.swtch.com/diffcover?utm_source=christophberger&utm_medium=email";
` + "```" + `

Another URL: https://example.com/article?id=123&utm_source=newsletter`,
			expected: `Check this URL: https://research.swtch.com/diffcover

` + "```" + `
var url = "https://research.swtch.com/diffcover?utm_source=christophberger&utm_medium=email";
` + "```" + `

Another URL: https://example.com/article?id=123`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveGenericTrackingParams(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}
-- core/links/google.go --
package links

import (
	"fmt"
	"io"
	"net/url"
	"strings"

	"mvdan.cc/xurls/v2"
)

var excludePatterns = []string{
	"google.com/maps/",
}

var KeepParams = []string{
	"q",
	"tbm",
}

var ParamsToRemove = []string{
	"bih",
	"biw",
	"client",
	"cshid",
	"dpr",
	"ei",
	"fbs",
	"gs_lcp",
	"gs_lcrp",
	"gs_lp",
	"gs_ssp",
	"hl",
	"ictx",
	"ie",
	"num",
	"oq",
	"prmd",
	"sa",
	"sca_esv",
	"sca_upv",
	"sclient",
	"sei",
	"source",
	"sourceid",
	"spell",
	"sqi",
	"stick",
	"sxsrf",
	"uact",
	"uds",
	"ved",
}

func RemoveParamsFromGoogleURLs(r io.Reader, w io.Writer) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("RemoveParamsFromGoogleLinks: failed to read input: %w", err)
	}

	codeBlockLevel := 0
	lines := strings.Split(string(buf), "\n")
	for i, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimmedLine, "```") {
			if codeBlockLevel == 0 {
				codeBlockLevel++
			} else {
				codeBlockLevel--
			}
		}

		if codeBlockLevel == 0 {
			rxStrict := xurls.Strict()
			lines[i] = rxStrict.ReplaceAllStringFunc(line, func(match string) string {
				if isExcludedURL(match) {
					return match
				}

				if strings.Contains(strings.ToLower(match), "google.com") {
					cleanedURL, _, err := cleanGoogleURL(match)
					if err != nil {
						return match
					}
					return cleanedURL
				}

				return match
			})
		}
	}

	_, err = w.Write([]byte(strings.Join(lines, "\n")))
	if err != nil {
		return fmt.Errorf("RemoveParamsFromGoogleLinks: failed to write output: %w", err)
	}

	return nil
}

func isExcludedURL(urlStr string) bool {
	for _, pattern := range excludePatterns {
		if strings.Contains(strings.ToLower(urlStr), pattern) {
			return true
		}
	}
	return false
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func cleanGoogleURL(urlStr string) (string, []string, error) {
	u, err := url.Parse(urlStr)
	if err != nil {
		return "", nil, err
	}

	q := u.Query()

	var remainingParams []string

	for param := range q {
		if contains(KeepParams, param) || !contains(ParamsToRemove, param) {
			remainingParams = append(remainingParams, param)
			continue
		}
		q.Del(param)
	}

	u.RawQuery = q.Encode()
	return u.String(), remainingParams, nil
}
-- core/links/google_test.go --
package links

import (
	"bytes"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestRemoveParamsFromGoogleLinks(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Google search link with parameters",
			input:    "https://www.google.com/search?q=test&bih=722&biw=1536&hl=en&sxsrf=ABC123",
			expected: "https://www.google.com/search?q=test",
		},
		{
			name:     "Google image search",
			input:    "https://www.google.com/search?udm=2&q=skiing",
			expected: "https://www.google.com/search?q=skiing&udm=2",
		},
		{
			name:     "Google link without parameters",
			input:    "https://www.google.com",
			expected: "https://www.google.com",
		},
		{
			name:     "Google Maps link (excluded)",
			input:    "https://www.google.com/maps/place/New+York",
			expected: "https://www.google.com/maps/place/New+York",
		},
		{
			name:     "Non-Google link",
			input:    "https://example.com?param=value",
			expected: "https://example.com?param=value",
		},
		{
			name: "Multiple Google links",
			input: `
Search result: https://www.google.com/search?q=test&bih=722&biw=1536&hl=en&sxsrf=ABC123
Maps link: https://www.google.com/maps/place/New+York
`,
			expected: `
Search result: https://www.google.com/search?q=test
Maps link: https://www.google.com/maps/place/New+York
`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveParamsFromGoogleURLs(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}
-- core/links/markdown.go --
package links

import (
	"fmt"
	"io"
	"regexp"
	"strings"
)

var (
	markdownLinkRegex          = regexp.MustCompile(`\[([^][]+)\](\(((?:[^()]+|\([^()]*\))+)\))`)
	markdownLinkWithTitleRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\s+"[^"]+"\)`)
	whitespaceRegex            = regexp.MustCompile(`[\s\t\n\r]+`)
)

func RemoveWhitespaceFromMarkdownLinks(r io.Reader, w io.Writer) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("CleanupMarkdownLinks: failed to read input: %w", err)
	}

	cleaned := markdownLinkRegex.ReplaceAllFunc(buf, func(match []byte) []byte {
		submatches := markdownLinkRegex.FindSubmatch(match)
		if len(submatches) >= 4 {
			description := whitespaceRegex.ReplaceAllString(string(submatches[1]), " ")
			description = strings.TrimSpace(description)
			url := string(submatches[3])
			return []byte(fmt.Sprintf("[%s](%s)", description, url))
		}
		return match
	})

	_, err = w.Write(cleaned)
	if err != nil {
		return fmt.Errorf("CleanupMarkdownLinks: failed to write output: %w", err)
	}

	return nil
}

func RemoveTitlesFromMarkdownLinks(r io.Reader, w io.Writer) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("RemoveTitlesFromMarkdownLinks: failed to read input: %w", err)
	}

	cleaned := markdownLinkWithTitleRegex.ReplaceAllFunc(buf, func(match []byte) []byte {
		return markdownLinkWithTitleRegex.ReplaceAll(match, []byte("[$1]($2)"))
	})

	_, err = w.Write(cleaned)
	if err != nil {
		return fmt.Errorf("RemoveTitlesFromMarkdownLinks: failed to write output: %w", err)
	}

	return nil
}
-- core/links/markdown_test.go --
package links

import (
	"bytes"
	"errors"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestCleanupMarkdownLinks(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: "No links",
			input: `
This is some text.
This more text.
Here is a link https://google.com.
`,
			expected: `
This is some text.
This more text.
Here is a link https://google.com.
`,
		},
		{
			name: "Single link with extra space",
			input: `
[    Google](https://google.com)
This is some text
[

Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters "Managing 100s of Kubernetes Clusters using Cluster API")
This more text.
Here is a link https://google.com.
`,
			expected: `
[Google](https://google.com)
This is some text
[Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters "Managing 100s of Kubernetes Clusters using Cluster API")
This more text.
Here is a link https://google.com.
`,
		},
		{
			name: "Multiple links with extra space",
			input: `
[Google](https://google.com)
This is some text
[
Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters "Managing 100s of Kubernetes Clusters using Cluster API")
This more text.
[

  Another link with space](https://example.com)
Here is a link https://google.com.
`,
			expected: `
[Google](https://google.com)
This is some text
[Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters "Managing 100s of Kubernetes Clusters using Cluster API")
This more text.
[Another link with space](https://example.com)
Here is a link https://google.com.
`,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveWhitespaceFromMarkdownLinks(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}

func TestCleanupMarkdownLinksErrors(t *testing.T) {
	t.Run("Read error", func(t *testing.T) {
		errReader := &errorReader{err: errors.New("read error")}
		var output bytes.Buffer
		err := RemoveWhitespaceFromMarkdownLinks(errReader, &output)
		if err == nil {
			t.Fatal("Expected an error, got nil")
		}
		if !strings.Contains(err.Error(), "CleanupMarkdownLinks: failed to read input: read error") {
			t.Errorf("Unexpected error message: %v", err)
		}
	})

	t.Run("Write error", func(t *testing.T) {
		input := strings.NewReader("some input")
		errWriter := &errorWriter{err: errors.New("write error")}
		err := RemoveWhitespaceFromMarkdownLinks(input, errWriter)
		if err == nil {
			t.Fatal("Expected an error, got nil")
		}
		if !strings.Contains(err.Error(), "CleanupMarkdownLinks: failed to write output: write error") {
			t.Errorf("Unexpected error message: %v", err)
		}
	})
}

func TestRemoveTitlesFromMarkdownLinks(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name: "No links",
			input: `
This is some text.
This more text.
Here is a link https://google.com.
`,
			expected: `
This is some text.
This more text.
Here is a link https://google.com.
`,
		},
		{
			name:     "Link with title",
			input:    `[Google](https://google.com "Search Engine")`,
			expected: `[Google](https://google.com)`,
		},
		{
			name: "Multiple links with titles",
			input: `
[Google](https://google.com "Search Engine")
This is some text
[Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters "Managing 100s of Kubernetes Clusters using Cluster API")
This more text.
[Another link](https://example.com "Example")
Here is a link https://google.com.
`,
			expected: `
[Google](https://google.com)
This is some text
[Managing 100s of Kubernetes Clusters using Cluster API](https://techblog.citystoragesystems.com/p/managing-100s-of-kubernetes-clusters)
This more text.
[Another link](https://example.com)
Here is a link https://google.com.
`,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveTitlesFromMarkdownLinks(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}

type errorReader struct {
	err error
}

func (e *errorReader) Read(p []byte) (n int, err error) {
	return 0, e.err
}

type errorWriter struct {
	err error
}

func (e *errorWriter) Write(p []byte) (n int, err error) {
	return 0, e.err
}
-- core/links/url.go --
package links

import (
	"fmt"
	"io"
	"net/url"
	"regexp"
	"strings"

	"mvdan.cc/xurls/v2"
)

var textFragmentRegex = regexp.MustCompile(`(?i)^:~:text=`)

func isYouTubeURL(u *url.URL) bool {
	youTubeDomains := []string{
		"youtube.com",
		"youtu.be",
	}
	for _, domain := range youTubeDomains {
		if strings.Contains(strings.ToLower(u.Hostname()), domain) {
			return true
		}
	}
	return false
}

func isSubstackURL(u *url.URL) bool {
	return strings.HasSuffix(strings.ToLower(u.Hostname()), ".substack.com")
}

func isTheSweeklyURL(u *url.URL) bool {
	return strings.HasSuffix(strings.ToLower(u.Hostname()), "thesweekly.com")
}

var theSweeklyParamsToRemove = []string{
	"utm_source",
	"publication_id",
	"post_id",
	"utm_campaign",
	"isFreemail",
	"r",
	"triedRedirect",
	"utm_medium",
}

func RemoveParamsFromYouTubeURLs(r io.Reader, w io.Writer) error {
	return processURLs(r, w, func(u *url.URL) *url.URL {
		if isYouTubeURL(u) {
			q := u.Query()
			q.Del("si")
			q.Del("app")
			u.RawQuery = q.Encode()
		}
		return u
	})
}

func RemoveParamsFromSubstackURLs(r io.Reader, w io.Writer) error {
	return processURLs(r, w, func(u *url.URL) *url.URL {
		if isSubstackURL(u) {
			u.RawQuery = ""
		}
		return u
	})
}

func RemoveParamsFromTheSweeklyURLs(r io.Reader, w io.Writer) error {
	return processURLs(r, w, func(u *url.URL) *url.URL {
		if isTheSweeklyURL(u) {
			q := u.Query()
			for _, param := range theSweeklyParamsToRemove {
				q.Del(param)
			}
			u.RawQuery = q.Encode()
		}
		return u
	})
}

func RemoveTextFragmentsFromURLs(r io.Reader, w io.Writer) error {
	return processURLs(r, w, func(u *url.URL) *url.URL {
		if isTextFragment(u.Fragment) {
			u.Fragment = ""
		}
		return u
	})
}

func isTextFragment(fragment string) bool {
	return textFragmentRegex.MatchString(fragment)
}

func processURLs(r io.Reader, w io.Writer, processor func(*url.URL) *url.URL) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("processURLs: failed to read input: %w", err)
	}

	codeBlockLevel := 0
	lines := strings.Split(string(buf), "\n")
	for i, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimmedLine, "```") {
			if codeBlockLevel == 0 {
				codeBlockLevel++
			} else {
				codeBlockLevel--
			}
		}

		if codeBlockLevel == 0 {
			rxStrict := xurls.Strict()
			lines[i] = rxStrict.ReplaceAllStringFunc(line, func(match string) string {
				u, err := url.Parse(match)
				if err != nil {
					return match
				}

				u = processor(u)

				return u.String()
			})
		}
	}

	_, err = w.Write([]byte(strings.Join(lines, "\n")))
	if err != nil {
		return fmt.Errorf("processURLs: failed to write output: %w", err)
	}

	return nil
}
-- core/links/url_test.go --
package links

import (
	"bytes"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestRemoveParamsFromYouTubeURLs(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "YouTube link with si and app parameters",
			input:    "https://youtu.be/JSKJbGi5oNA?si=b2GkFDivckm1k-Mq&app=Desktop",
			expected: "https://youtu.be/JSKJbGi5oNA",
		},
		{
			name:     "YouTube link without si parameter",
			input:    "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
			expected: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
		},
		{
			name:     "Non-YouTube link",
			input:    "https://example.com?param=value",
			expected: "https://example.com?param=value",
		},
		{
			name: "Multiple YouTube links",
			input: `
Check out this video: https://youtu.be/JSKJbGi5oNA?si=b2GkFDivckm1k-Mq
And this one: https://www.youtube.com/watch?v=dQw4w9WgXcQ&si=AnotherParam
`,
			expected: `
Check out this video: https://youtu.be/JSKJbGi5oNA
And this one: https://www.youtube.com/watch?v=dQw4w9WgXcQ
`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveParamsFromYouTubeURLs(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}

func TestRemoveParamsFromSubstackURLs(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Substack link with parameters",
			input:    "https://example.substack.com/p/article-title?utm_source=twitter&utm_medium=social",
			expected: "https://example.substack.com/p/article-title",
		},
		{
			name:     "Substack link without parameters",
			input:    "https://another.substack.com/p/another-article",
			expected: "https://another.substack.com/p/another-article",
		},
		{
			name:     "Non-Substack link",
			input:    "https://example.com?param=value",
			expected: "https://example.com?param=value",
		},
		{
			name: "Multiple Substack links",
			input: `
Check out this article: https://first.substack.com/p/title?utm_source=twitter
And this one: https://second.substack.com/p/another-title?utm_campaign=post
`,
			expected: `
Check out this article: https://first.substack.com/p/title
And this one: https://second.substack.com/p/another-title
`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveParamsFromSubstackURLs(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}

func TestRemoveTextFragments(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Link with text fragment",
			input:    "https://example.com/article#:~:text=some%20text",
			expected: "https://example.com/article",
		},
		{
			name:     "Link with regular fragment",
			input:    "https://example.com/article#heading-1",
			expected: "https://example.com/article#heading-1",
		},
		{
			name:     "Link without fragment",
			input:    "https://example.com/article",
			expected: "https://example.com/article",
		},
		{
			name: "Multiple links with text fragments",
			input: `
Check out this article: https://example.com/article1#:~:text=some%20text
And this one: https://example.com/article2#another-fragment
`,
			expected: `
Check out this article: https://example.com/article1
And this one: https://example.com/article2#another-fragment
`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveTextFragmentsFromURLs(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}
-- core/links/ytcount.go --
package links

import (
	"fmt"
	"io"
	"regexp"
)

var youtubeCountRegex *regexp.Regexp

func init() {
	var err error
	youtubeCountRegex, err = buildYouTubeCountRegex()
	if err != nil {
		panic(fmt.Sprintf("Failed to build YouTube count regex: %v", err))
	}
}

func buildYouTubeCountRegex() (*regexp.Regexp, error) {
	count := `\(\d+\)`
	title := `.+?`
	youtubeURLs := `(?:youtube\.com|youtu\.be)`
	url := `https?://(?:www\.)?` + youtubeURLs + `/[^\s]+`
	optionalTitle := `(?:\s+"[^"]*")?`

	pattern := fmt.Sprintf(`\[\s*(%s)\s*(%s)\]\((%s)(%s)\)`, count, title, url, optionalTitle)

	return regexp.Compile(pattern)
}

func RemoveYouTubeCountFromMarkdownLinks(r io.Reader, w io.Writer) error {
	buf, err := io.ReadAll(r)
	if err != nil {
		return fmt.Errorf("RemoveYouTubeCountFromLinks: failed to read input: %w", err)
	}

	cleaned := youtubeCountRegex.ReplaceAllFunc(buf, func(match []byte) []byte {
		return youtubeCountRegex.ReplaceAll(match, []byte("[$2]($3$4)"))
	})

	_, err = w.Write(cleaned)
	if err != nil {
		return fmt.Errorf("RemoveYouTubeCountFromLinks: failed to write output: %w", err)
	}

	return nil
}
-- core/links/ytcount_test.go --
package links

import (
	"bytes"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestRemoveYouTubeCountFromLinks(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "YouTube link with count",
			input:    "[(1619) Understanding Neovim #1 - Installation - YouTube](https://www.youtube.com/watch?v=87AXw9Quy9U&list=PLx2ksyallYzW4WNYHD9xOFrPRYGlntAft \"(1619) Understanding Neovim #1 - Installation - YouTube\")",
			expected: "[Understanding Neovim #1 - Installation - YouTube](https://www.youtube.com/watch?v=87AXw9Quy9U&list=PLx2ksyallYzW4WNYHD9xOFrPRYGlntAft \"(1619) Understanding Neovim #1 - Installation - YouTube\")",
		},
		{
			name:     "YouTube short link with count",
			input:    "[(2345) Short YouTube Video](https://youtu.be/dQw4w9WgXcQ)",
			expected: "[Short YouTube Video](https://youtu.be/dQw4w9WgXcQ)",
		},
		{
			name:     "YouTube short link with count and spaces",
			input:    "[      (2345)        Short YouTube Video](https://youtu.be/dQw4w9WgXcQ)",
			expected: "[Short YouTube Video](https://youtu.be/dQw4w9WgXcQ)",
		},
		{
			name:     "YouTube link without count",
			input:    "[Understanding Neovim #1 - Installation - YouTube](https://www.youtube.com/watch?v=87AXw9Quy9U&list=PLx2ksyallYzW4WNYHD9xOFrPRYGlntAft)",
			expected: "[Understanding Neovim #1 - Installation - YouTube](https://www.youtube.com/watch?v=87AXw9Quy9U&list=PLx2ksyallYzW4WNYHD9xOFrPRYGlntAft)",
		},
		{
			name:     "Non-YouTube link",
			input:    "[Example Link](https://example.com)",
			expected: "[Example Link](https://example.com)",
		},
		{
			name: "Multiple YouTube links",
			input: `
[(1234) First Video - YouTube](https://www.youtube.com/watch?v=abc123)
[(5678) Second Video - YouTube](https://youtu.be/def456 "Some title")
[Regular Link](https://example.com)
`,
			expected: `
[First Video - YouTube](https://www.youtube.com/watch?v=abc123)
[Second Video - YouTube](https://youtu.be/def456 "Some title")
[Regular Link](https://example.com)
`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			input := strings.NewReader(tc.input)
			var output bytes.Buffer
			err := RemoveYouTubeCountFromMarkdownLinks(input, &output)
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}
			result := output.String()
			if diff := cmp.Diff(tc.expected, result); diff != "" {
				t.Errorf("Unexpected result (-want +got):\n%s", diff)
			}
		})
	}
}
-- core/utils.go --
package core

import (
	"bytes"
	"io"
)

func ApplyTransforms(content []byte, transforms ...func(io.Reader, io.Writer) error) ([]byte, error) {
	var processedContent bytes.Buffer
	currentContent := bytes.NewReader(content)

	for _, transform := range transforms {
		processedContent.Reset()
		err := transform(currentContent, &processedContent)
		if err != nil {
			return nil, err
		}
		currentContent = bytes.NewReader(processedContent.Bytes())
	}

	return processedContent.Bytes(), nil
}
-- file/type.go --
package file

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type File struct {
	Path string
}

func (f File) IsSymlink() (bool, error) {
	fileInfo, err := os.Lstat(f.Path)
	if err != nil {
		return false, err
	}
	return fileInfo.Mode()&os.ModeSymlink != 0, nil
}

func (f File) FileType() string {
	// Get file info without following symlinks
	info, err := os.Lstat(f.Path)
	if err != nil {
		return "Error: Unable to get file info"
	}

	// Check if it's a symlink
	if info.Mode()&os.ModeSymlink != 0 {
		// If it's a symlink, we can optionally get the target
		target, err := os.Readlink(f.Path)
		if err != nil {
			return "Symlink (unable to read target)"
		}
		return fmt.Sprintf("Symlink to %s", target)
	}

	// If it's not a symlink, proceed with file type detection
	if info.IsDir() {
		return "Directory"
	}

	ext := strings.ToLower(filepath.Ext(f.Path))
	switch ext {
	case ".txt":
		return "Text File"
	case ".go":
		return "Go Source File"
	case ".jpg", ".jpeg":
		return "JPEG Image"
	case ".png":
		return "PNG Image"
	case ".pdf":
		return "PDF Document"
	default:
		return "Unknown File Type"
	}
}
-- file/type_test.go --
package file

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestFileType(t *testing.T) {
	// Create a temporary directory for our test files
	tmpDir, err := os.MkdirTemp("", "filetest")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Test cases
	tests := []struct {
		name     string
		setup    func() (string, error)
		expected string
	}{
		{
			name: "Text File",
			setup: func() (string, error) {
				path := filepath.Join(tmpDir, "test.txt")
				err := os.WriteFile(path, []byte("test"), 0o644)
				return path, err
			},
			expected: "Text File",
		},
		{
			name: "Go Source File",
			setup: func() (string, error) {
				path := filepath.Join(tmpDir, "test.go")
				err := os.WriteFile(path, []byte("package main"), 0o644)
				return path, err
			},
			expected: "Go Source File",
		},
		{
			name: "JPEG Image",
			setup: func() (string, error) {
				path := filepath.Join(tmpDir, "test.jpg")
				err := os.WriteFile(path, []byte("fake jpg"), 0o644)
				return path, err
			},
			expected: "JPEG Image",
		},
		{
			name: "Directory",
			setup: func() (string, error) {
				path := filepath.Join(tmpDir, "testdir")
				err := os.Mkdir(path, 0o755)
				return path, err
			},
			expected: "Directory",
		},
		{
			name: "Symlink",
			setup: func() (string, error) {
				target := filepath.Join(tmpDir, "target.txt")
				err := os.WriteFile(target, []byte("target"), 0o644)
				if err != nil {
					return "", err
				}
				link := filepath.Join(tmpDir, "symlink")
				err = os.Symlink(target, link)
				return link, err
			},
			expected: "Symlink to ", // We'll check if it starts with this
		},
		{
			name: "Unknown File Type",
			setup: func() (string, error) {
				path := filepath.Join(tmpDir, "test.xyz")
				err := os.WriteFile(path, []byte("unknown"), 0o644)
				return path, err
			},
			expected: "Unknown File Type",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			path, err := tt.setup()
			if err != nil {
				t.Fatalf("Setup failed: %v", err)
			}

			file := File{Path: path}
			result := file.FileType()

			if tt.name == "Symlink" {
				if !strings.HasPrefix(result, tt.expected) {
					t.Errorf("FileType() = %v, want prefix %v", result, tt.expected)
				}
			} else if result != tt.expected {
				t.Errorf("FileType() = %v, want %v", result, tt.expected)
			}
		})
	}
}
-- go.sum --
dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
github.com/Microsoft/go-winio v0.5.2/go.mod h1:WpS1mjBmmwHBEWmogvA2mj8546UReBk4v8QkMxJ6pZY=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/ProtonMail/go-crypto v1.1.6 h1:ZcV+Ropw6Qn0AX9brlQLAUXfqLBc7Bl+f/DmNxpLfdw=
github.com/ProtonMail/go-crypto v1.1.6/go.mod h1:rA3QumHc/FZ8pAHreoekgiAbzpNsfQAosU5td4SnOrE=
github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=
github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=
github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=
github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=
github.com/cloudflare/circl v1.6.1 h1:zqIqSPIndyBh1bjLVVDHMPpVKqp8Su/V+6MeDzzQBQ0=
github.com/cloudflare/circl v1.6.1/go.mod h1:uddAzsPgqdMAYatqJ0lsjX1oECcQLIlRpzZh3pJrofs=
github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/cyphar/filepath-securejoin v0.4.1 h1:JyxxyPEaktOD+GAnqIqTf9A8tHyAG22rowi7HkoSU1s=
github.com/cyphar/filepath-securejoin v0.4.1/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/elazarl/goproxy v1.7.2 h1:Y2o6urb7Eule09PjlhQRGNsqRfPmYI3KKQLFpCAV3+o=
github.com/elazarl/goproxy v1.7.2/go.mod h1:82vkLNir0ALaW14Rc399OTTjyNREgmdL2cVoIbS6XaE=
github.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=
github.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=
github.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=
github.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=
github.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=
github.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.9.0 h1:2Ml+OJNzbYCTzsxtv8vKSFD9PbJjmhYF14k/jKC7S9k=
github.com/fsnotify/fsnotify v1.9.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=
github.com/gliderlabs/ssh v0.3.8 h1:a4YXD1V7xMF9g5nTkdfnja3Sxy1PVDCj1Zg4Wb8vY6c=
github.com/gliderlabs/ssh v0.3.8/go.mod h1:xYoytBv1sV0aL3CavoDuJIQNURXkkfPA/wxQ1pL1fAU=
github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 h1:+zs/tPmkDkHx3U66DAb0lQFJrpS6731Oaa12ikc+DiI=
github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376/go.mod h1:an3vInlBmSxCcxctByoQdvwPiA7DTK7jaaFDBTtu0ic=
github.com/go-git/go-billy/v5 v5.6.2 h1:6Q86EsPXMa7c3YZ3aLAQsMA0VlWmy43r6FHqa/UNbRM=
github.com/go-git/go-billy/v5 v5.6.2/go.mod h1:rcFC2rAsp/erv7CMz9GczHcuD0D32fWzH+MJAU+jaUU=
github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399 h1:eMje31YglSBqCdIqdhKBW8lokaMrL3uTkpGYlE2OOT4=
github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399/go.mod h1:1OCfN199q1Jm3HZlxleg+Dw/mwps2Wbk9frAWm+4FII=
github.com/go-git/go-git/v5 v5.16.0 h1:k3kuOEpkc0DeY7xlL6NaaNg39xdgQbtH5mwCafHO9AQ=
github.com/go-git/go-git/v5 v5.16.0/go.mod h1:4Ge4alE/5gPs30F2H1esi2gPd69R0C39lolkucHBOp8=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/zapr v1.3.0 h1:XGdV8XW8zdwFiwOA2Dryh1gj2KRQyOOoNmBy4EplIcQ=
github.com/go-logr/zapr v1.3.0/go.mod h1:YKepepNBd1u/oyhd/yQmtjVXmm9uML4IXUgMOwR8/Gg=
github.com/go-logr/zerologr v1.2.3 h1:up5N9vcH9Xck3jJkXzgyOxozT14R47IyDODz8LM1KSs=
github.com/go-logr/zerologr v1.2.3/go.mod h1:BxwGo7y5zgSHYR1BjbnHPyF/5ZjVKfKxAZANVu6E8Ho=
github.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=
github.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=
github.com/go-viper/mapstructure/v2 v2.2.1 h1:ZAaOCxANMuZx5RCeg0mBdEZk7DZasvvZIxtHqx8aGss=
github.com/go-viper/mapstructure/v2 v2.2.1/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 h1:f+oWsMOmNPc8JmEHVZIycC7hBoQxHH9pNKQORJNozsQ=
github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8/go.mod h1:wcDNUvekVysuuOpQKo3191zZyTpiI6se1N1ULghS0sw=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/go-containerregistry v0.20.3 h1:oNx7IdTI936V8CQRveCjaxOiegWwvM7kqkbXTpyiovI=
github.com/google/go-containerregistry v0.20.3/go.mod h1:w00pIgBRDVUDFM6bq+Qx8lwNWK+cxgCuX1vd3PIBDNI=
github.com/google/pprof v0.0.0-20241029153458-d1b30febd7db h1:097atOisP2aRj7vFgYQBbFN4U4JNXUNYpxael3UzMyo=
github.com/google/pprof v0.0.0-20241029153458-d1b30febd7db/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=
github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=
github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=
github.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/magefile/mage v1.15.0 h1:BvGheCMAsG3bWUDbZ8AyXXpCNwU9u5CB6sM+HNb9HYg=
github.com/magefile/mage v1.15.0/go.mod h1:z5UZb/iS3GoOSn0JgWuiw7dxlurVYTu+/jHXqQg881A=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/onsi/ginkgo/v2 v2.22.0 h1:Yed107/8DjTr0lKCNt7Dn8yQ6ybuDRQoMGrNFKzMfHg=
github.com/onsi/ginkgo/v2 v2.22.0/go.mod h1:7Du3c42kxCUegi0IImZ1wUQzMBVecgIHjR1C+NkhLQo=
github.com/onsi/gomega v1.36.1 h1:bJDPBO7ibjxcbHMgSCoo4Yj18UWbKDlLwX1x9sybDcw=
github.com/onsi/gomega v1.36.1/go.mod h1:PvZbdDc8J6XJEpDK4HCuRBm8a6Fzp9/DmhC9C7yFlog=
github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
github.com/pjbgf/sha1cd v0.3.2 h1:a9wb0bp1oC2TGwStyn0Umc/IGKQnEgF0vVaZ8QF8eo4=
github.com/pjbgf/sha1cd v0.3.2/go.mod h1:zQWigSxVmsHEZow5qaLtPYxpcKMMQpa09ixqBxuCS6A=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.14.1 h1:UQB4HGPB6osV0SQTLymcB4TgvyWu6ZyliaW0tI/otEQ=
github.com/rogpeppe/go-internal v1.14.1/go.mod h1:MaRKkUm5W0goXpeCfT7UZI6fk/L7L7so1lCWt35ZSgc=
github.com/rs/xid v1.6.0/go.mod h1:7XoLgs4eV+QndskICGsho+ADou8ySMSjJKDIan90Nz0=
github.com/rs/zerolog v1.34.0 h1:k43nTLIwcTVQAncfCw4KZ2VY6ukYoZaBPNOE8txlOeY=
github.com/rs/zerolog v1.34.0/go.mod h1:bJsvje4Z08ROH4Nhs5iH600c3IkWhwp44iRc54W6wYQ=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/sagikazarmark/locafero v0.7.0 h1:5MqpDsTGNDhY8sGp0Aowyf0qKsPrhewaLSsFaodPcyo=
github.com/sagikazarmark/locafero v0.7.0/go.mod h1:2za3Cg5rMaTMoG/2Ulr9AwtFaIppKXTRYnozin4aB5k=
github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=
github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/skeema/knownhosts v1.3.1 h1:X2osQ+RAjK76shCbvhHHHVl3ZlgDm8apHEHFqRjnBY8=
github.com/skeema/knownhosts v1.3.1/go.mod h1:r7KTdC8l4uxWRyK2TpQZ/1o5HaSzh06ePQNxPwTcfiY=
github.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=
github.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=
github.com/spf13/afero v1.12.0 h1:UcOPyRBYczmFn6yvphxkn9ZEOY65cpwGKb5mL36mrqs=
github.com/spf13/afero v1.12.0/go.mod h1:ZTlWwG4/ahT8W7T0WQ5uYmjI9duaLQGy3Q2OAl4sk/4=
github.com/spf13/cast v1.7.1 h1:cuNEagBQEHWN1FnbGEjCXL2szYEXqfJPbP2HNUaca9Y=
github.com/spf13/cast v1.7.1/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=
github.com/spf13/cobra v1.9.1 h1:CXSaggrXdbHK9CF+8ywj8Amf7PBRmPCOJugH954Nnlo=
github.com/spf13/cobra v1.9.1/go.mod h1:nDyEzZ8ogv936Cinf6g1RU9MRY64Ir93oCnqb9wxYW0=
github.com/spf13/pflag v1.0.6 h1:jFzHGLGAlb3ruxLB8MhbI6A8+AQX/2eW4qeyNZXNp2o=
github.com/spf13/pflag v1.0.6/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.20.1 h1:ZMi+z/lvLyPSCoNtFCpqjy0S4kPbirhpTMwl8BkW9X4=
github.com/spf13/viper v1.20.1/go.mod h1:P9Mdzt1zoHIG8m2eZQinpiBjo6kCmZSKBClNNqjJvu4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=
github.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=
github.com/xanzy/ssh-agent v0.3.3 h1:+/15pJfg/RsTxqYcX6fHqOXZwwMP+2VyYWJeWM2qQFM=
github.com/xanzy/ssh-agent v0.3.3/go.mod h1:6dzNDKs0J9rVPHPhaGCukekBHKqfl+L3KghI1Bc68Uw=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=
go.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=
golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.31.0 h1:erwDkOK1Msy6offm1mOgvspSkslFnIGsFnxOKoufg3o=
golang.org/x/term v0.31.0/go.mod h1:R4BeIy7D95HzImkxGkTW1UQTtP54tio2RyHz7PwK0aw=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.29.0 h1:Xx0h3TtM9rzQpQuR4dKLrdglAmCEN5Oi+P74JdhdzXE=
golang.org/x/tools v0.29.0/go.mod h1:KMQVMRsVxU6nHCFXrBPhDB8XncLNLM0lIy/F14RP588=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=
gopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
mvdan.cc/xurls/v2 v2.6.0 h1:3NTZpeTxYVWNSokW3MKeyVkz/j7uYXYiMtXRUfmjbgI=
mvdan.cc/xurls/v2 v2.6.0/go.mod h1:bCvEZ1XvdA6wDnxY7jPPjEmigDtvtvPXAD/Exa9IMSk=
sigs.k8s.io/controller-runtime v0.20.4 h1:X3c+Odnxz+iPTRobG4tp092+CvBU9UK0t/bRf+n0DGU=
sigs.k8s.io/controller-runtime v0.20.4/go.mod h1:xg2XB0K5ShQzAgsoujxuKN4LNXR2LfwwHsPj7Iaw+XY=
-- internal/logger/logger.go --
package logger

import (
	"io"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/fatih/color"
	"github.com/go-logr/logr"
	"github.com/go-logr/zerologr"
	gcrLog "github.com/google/go-containerregistry/pkg/logs"
	"github.com/rs/zerolog"
	runtimeLog "sigs.k8s.io/controller-runtime/pkg/log"
)

func NewConsoleLogger(verbose, jsonFormat bool) logr.Logger {
	var zlog zerolog.Logger

	zerolog.CallerMarshalFunc = func(pc uintptr, file string, line int) string {
		relPath, err := filepath.Rel(".", file)
		if err != nil {
			relPath = file
		}
		return relPath + ":" + strconv.Itoa(line)
	}

	if jsonFormat {
		zlog = zerolog.New(os.Stderr).With().Timestamp().Caller().Logger()
	} else {
		color.NoColor = !verbose
		consoleWriter := zerolog.ConsoleWriter{
			Out:        os.Stderr,
			NoColor:    !verbose,
			TimeFormat: time.Kitchen,
		}

		if !verbose {
			consoleWriter.PartsExclude = []string{zerolog.TimestampFieldName}
		}

		zlog = zerolog.New(consoleWriter).With().Timestamp().Caller().Logger()
	}

	if verbose {
		zlog = zlog.Level(zerolog.DebugLevel)
	} else {
		zlog = zlog.Level(zerolog.InfoLevel)
	}

	gcrLog.Warn.SetOutput(io.Discard)

	zerologr.VerbosityFieldName = "v"
	log := zerologr.New(&zlog)

	runtimeLog.SetLogger(log)

	return log
}
-- main.go --
package main

import "github.com/gkwa/littlewill/cmd"

func main() {
	cmd.Execute()
}
-- version/version.go --
package version

import "fmt"

type BuildInfo struct {
	Date        string
	FullGitSHA  string
	GoVersion   string
	ShortGitSHA string
	Version     string
}

func (bi BuildInfo) String() string {
	return fmt.Sprintf(`Version: %s, %s
Build Date: %s
Go Version: %s`, bi.Version, bi.FullGitSHA, bi.Date, bi.GoVersion)
}

var (
	Date        string
	FullGitSHA  string
	GoVersion   string
	ShortGitSHA string
	Version     string
)

func GetBuildInfo() BuildInfo {
	return BuildInfo{
		Date:        Date,
		FullGitSHA:  FullGitSHA,
		GoVersion:   GoVersion,
		ShortGitSHA: ShortGitSHA,
		Version:     Version,
	}
}
-- watcher/filter.go --
package watcher

import (
	"path/filepath"

	"github.com/fsnotify/fsnotify"
)

type FilterType int

const (
	FilterTypeCreate FilterType = iota
	FilterTypeWrite
	FilterTypeRemove
	FilterTypeRename
	FilterTypeChmod
)

type Filter struct {
	Pattern string
	Type    FilterType
}

func shouldTrigger(event fsnotify.Event, filters []Filter) bool {
	if len(filters) == 0 {
		return true
	}

	for _, filter := range filters {
		match, _ := filepath.Match(filter.Pattern, filepath.Base(event.Name))
		if match {
			switch filter.Type {
			case FilterTypeCreate:
				if event.Op&fsnotify.Create == fsnotify.Create {
					return true
				}
			case FilterTypeWrite:
				if event.Op&fsnotify.Write == fsnotify.Write {
					return true
				}
			case FilterTypeRemove:
				if event.Op&fsnotify.Remove == fsnotify.Remove {
					return true
				}
			case FilterTypeRename:
				if event.Op&fsnotify.Rename == fsnotify.Rename {
					return true
				}
			case FilterTypeChmod:
				if event.Op&fsnotify.Chmod == fsnotify.Chmod {
					return true
				}
			}
		}
	}
	return false
}
-- watcher/watcher.go --
package watcher

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"

	"github.com/fsnotify/fsnotify"
	"github.com/gkwa/littlewill/core"
	"github.com/go-logr/logr"
)

var ignoredEvents = []fsnotify.Op{
	fsnotify.Chmod,
	fsnotify.Remove,
	fsnotify.Rename,
}

type EventHandler func(event fsnotify.Event, path string)

func RunWatcher(
	ctx context.Context,
	dirToWatch string,
	patterns []string,
	filterType string,
	linkTransforms []func(io.Reader, io.Writer) error,
) {
	logger := logr.FromContextOrDiscard(ctx)

	handler := func(event fsnotify.Event, path string) {
		time.Sleep(time.Second)
		fmt.Printf("Event: %s, File: %s\n", event.Op, path)

		err := core.ProcessFile(logger, path, linkTransforms...)
		if err != nil {
			logger.Error(err, "Failed to process file", "path", path)
		}
	}
	err := Run(ctx, dirToWatch, patterns, filterType, handler)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func Run(
	ctx context.Context,
	dirPath string,
	patterns []string,
	filterTypeStr string,
	handler EventHandler,
) error {
	logger := logr.FromContextOrDiscard(ctx)
	logger.Info("Starting directory watcher", "directory", dirPath)

	filters := makeFilters(patterns, parseFilterType(filterTypeStr))

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return fmt.Errorf("error creating watcher: %w", err)
	}
	defer watcher.Close()

	done := make(chan bool)
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}
				if shouldTrigger(event, filters) && !isIgnoredEvent(event.Op) {
					absPath, err := filepath.Abs(event.Name)
					if err != nil {
						logger.Error(err, "Error getting absolute path", "file", event.Name)
						continue
					}
					handler(event, absPath)
					logger.V(1).Info("File event", "event", event.Op.String(), "file", absPath)
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				logger.Error(err, "Error from watcher")
			case <-ctx.Done():
				return
			}
		}
	}()

	err = watcher.Add(dirPath)
	if err != nil {
		return fmt.Errorf("error adding directory to watcher: %w", err)
	}

	<-done
	return nil
}

func isIgnoredEvent(op fsnotify.Op) bool {
	for _, ignoredOp := range ignoredEvents {
		if op == ignoredOp {
			return true
		}
	}
	return false
}

func makeFilters(patterns []string, filterType FilterType) []Filter {
	filters := make([]Filter, 0, len(patterns))
	for _, pattern := range patterns {
		filters = append(filters, Filter{
			Pattern: pattern,
			Type:    filterType,
		})
	}
	return filters
}

func parseFilterType(filterType string) FilterType {
	switch filterType {
	case "create":
		return FilterTypeCreate
	case "write":
		return FilterTypeWrite
	case "remove":
		return FilterTypeRemove
	case "rename":
		return FilterTypeRename
	case "chmod":
		return FilterTypeChmod
	default:
		return FilterTypeWrite
	}
}
